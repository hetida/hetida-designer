{
  "category": "Statistic",
  "content": "import pandas as pd\n\n\ndef calculate_window_size(\n    series: pd.Series, min_num_desired_datapoints_in_window: int, buffer_factor: float\n) -> float:\n    \"\"\"Window size calculation.\n\n    Function to calculate the window size in seconds for the analysis of a timeseries with moving\n    windows.\n\n    series (Pandas Series): Series for which the calculation is supposed to be performed.\n        The indices must be datetimes.\n    min_num_desired_datapoints_in_window (Integer): Minimum number of datapoints supposed to be in\n        each window.\n    buffer_factor (Float): Factor to multiply min_num_desired_datapoints_in_window with in order to\n        control the expected number of datapoints inside each window.\n\n\n    Returns: Calculated window size in seconds.\n    \"\"\"\n    if not isinstance(series.index, pd.DatetimeIndex):\n        raise TypeError(\"This component is exclusively for series with Datetime index!\")\n\n    median_diff = series.sort_index().index.to_series().diff().median().seconds\n\n    return median_diff * (min_num_desired_datapoints_in_window * buffer_factor)\n\n\ndef create_pandas_frequency_string(number_of_seconds: float) -> str:\n    return str(number_of_seconds) + \"S\"\n\n\n# ***** DO NOT EDIT LINES BELOW *****\n# These lines may be overwritten if component details or inputs/outputs change.\nCOMPONENT_INFO = {\n    \"inputs\": {\n        \"series\": \"SERIES\",\n        \"min_num_desired_datapoints_in_window\": \"INT\",\n        \"buffer_factor\": \"FLOAT\",\n    },\n    \"outputs\": {\n        \"frequency_string\": \"STRING\",\n    },\n    \"name\": \"Infer Window Size\",\n    \"category\": \"Statistic\",\n    \"description\": \"Infers the size to choose for a moving window\",\n    \"version_tag\": \"1.0.0\",\n    \"id\": \"4615ec0d-99bd-40ba-a88b-643dd28fa6e7\",\n    \"revision_group_id\": \"a9614fc3-e7a0-4df1-8a8c-a1c8cadeb84b\",\n    \"state\": \"RELEASED\",\n    \"released_timestamp\": \"2022-11-24T17:06:12.073942+00:00\",\n}\n\n\ndef main(*, series, min_num_desired_datapoints_in_window, buffer_factor):\n    # entrypoint function for this component\n    # ***** DO NOT EDIT LINES ABOVE *****\n    # write your function code here.\n\n    window_size = calculate_window_size(\n        series=series,\n        min_num_desired_datapoints_in_window=min_num_desired_datapoints_in_window,\n        buffer_factor=buffer_factor,\n    )\n\n    return {\"frequency_string\": create_pandas_frequency_string(window_size)}\n",
  "description": "Infers the size to choose for a moving window",
  "documentation": "# Infer Window Size\n\n## Description\nThis component calculates the window size for a given time series and creates a pandas frequency string for it.\n\n## Inputs\n* **series** (Pandas Series): Series for which the calculation is supposed to be performed. The indices must be datetimes.\n* **min_num_desired_datapoints_in_window** (Integer): Minimum number of datapoints supposed to be in each window.\n* **buffer_factor** (Float): Factor to multiply *min_num_desired_datapoints_in_window* with in order to control the expected number of datapoints inside each window.\n\n## Outputs\n* **frequency_string** (String): The created pandas frequency string.\n\n## Details\nThis component calculates the window size for a given time series based on the median time difference between two consecutive datapoints in seconds. This value is assumed to be the expected time difference between two datapoints for the following steps.\n\nThe input **min_num_desired_datapoints_in_window** specifies the minimum number of datapoints desired to be inside each window. A reasonable value is 30 to assume sampling normality.\n\nThe input **buffer_factor** is a decimal factor by which **min_num_desired_datapoints_in_window** is multiplied before calculating the window size. If the value is 1, the majority of windows are expected to contain this number of datapoints, but depending on the input series, some windows may contain more and some fewer datapoints. To achieve that a larger number of windows contain at least the specified number of datapoints, the **buffer_factor** should be greater than 1. This results in the expected number of datapoints in each window being higher than the specified minimum number. For values smaller than 1, the window size will be correspondingly smaller, so that the windows are expected to contain fewer datapoints than desired.\n\nThe calculated median is multiplied with these two inputs and converted into seconds to get the window size.\n\nThe result of the calculation is converted into a [pandas frequency string](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases) to be able to use it as frequency input of pandas functions, e.g. *pandas.DataFrame.rolling*. The string is always in seconds. The format works for both large and small time ranges even though metrics other than seconds might make more sense depending on the individual case.\n\n## Examples\nThe json input of a typical call of this component is\n```\n{\n    \"series\": {\n        \"2022-01-01T00:00:00Z\": 1.058,\n        \"2022-01-01T00:20:48Z\": 0.699,\n        \"2022-01-01T00:41:37Z\": 1.08,\n        \"2022-01-01T01:02:26Z\": 1.054,\n        \"2022-01-01T01:23:15Z\": 0.763,\n        \"2022-01-01T01:44:04Z\": 1.034,\n        \"2022-01-01T02:04:53Z\": 0.965,\n        \"2022-01-01T02:25:42Z\": 0.601,\n        \"2022-01-01T02:46:31Z\": 0.933,\n        \"2022-01-01T03:07:20Z\": 1.081,\n        \"2022-01-01T03:28:09Z\": 2.1,\n        \"2022-01-01T03:48:58Z\": 0.988,\n        \"2022-01-01T04:09:47Z\": 0.741,\n        \"2022-01-01T04:30:36Z\": 0.647,\n        \"2022-01-01T04:51:25Z\": 0.556,\n        \"2022-01-01T05:12:14Z\": 0.453,\n        \"2022-01-01T05:33:03Z\": 1.009,\n        \"2022-01-01T05:53:52Z\": 1.72,\n        \"2022-01-01T06:14:41Z\": 1.002,\n        \"2022-01-01T06:56:19Z\": 0.857,\n        \"2022-01-01T07:17:08Z\": 0.864,\n        \"2022-01-01T07:37:57Z\": 0.606,\n        \"2022-01-01T07:58:46Z\": 0.899,\n        \"2022-01-01T08:40:24Z\": 0.62,\n        \"2022-01-01T10:03:40Z\": 0.721,\n        \"2022-01-01T10:24:29Z\": 1.193,\n        \"2022-01-01T10:45:18Z\": 0.833,\n        \"2022-01-01T11:06:07Z\": 2.06,\n        \"2022-01-01T11:26:56Z\": 0.68,\n        \"2022-01-01T11:47:45Z\": 1.136,\n        \"2022-01-01T12:08:34Z\": 0.62,\n        \"2022-01-01T12:29:23Z\": 0.946,\n        \"2022-01-01T12:50:12Z\": 0.746,\n        \"2022-01-01T13:11:01Z\": 0.833,\n        \"2022-01-01T13:31:50Z\": 0.857,\n        \"2022-01-01T14:13:28Z\": 0.947,\n        \"2022-01-01T14:34:17Z\": 0.841,\n        \"2022-01-01T14:55:06Z\": 0.668,\n        \"2022-01-01T15:15:55Z\": 0.675,\n        \"2022-01-01T15:36:44Z\": 0.84,\n        \"2022-01-01T15:57:33Z\": 0.821,\n        \"2022-01-01T16:18:22Z\": 0.625,\n        \"2022-01-01T16:39:11Z\": 1.155,\n        \"2022-01-01T17:00:00Z\": 0.968\n    },\n    \"min_num_desired_datapoints_in_window\": 10,\n    \"buffer_factor\": 1.4\n}\n```\nThe expected output is\n```\n{\n    \"frequency_string\": \"17486.0S\"\n}\n```\n",
  "id": "4615ec0d-99bd-40ba-a88b-643dd28fa6e7",
  "io_interface": {
    "inputs": [
      {
        "data_type": "SERIES",
        "id": "c85c22fe-6e56-4f3e-a969-552847ac013f",
        "name": "series"
      },
      {
        "data_type": "INT",
        "id": "861001bc-7d9e-4315-8290-3af665a98417",
        "name": "min_num_desired_datapoints_in_window"
      },
      {
        "data_type": "FLOAT",
        "id": "57af13c4-c4be-4cc0-9d49-098154bc23bc",
        "name": "buffer_factor"
      }
    ],
    "outputs": [
      {
        "data_type": "STRING",
        "id": "c8a9eff0-b531-482e-90d8-0d19903f7f4f",
        "name": "frequency_string"
      }
    ]
  },
  "name": "Infer Window Size",
  "released_timestamp": "2022-11-24T17:06:12.073942+00:00",
  "revision_group_id": "a9614fc3-e7a0-4df1-8a8c-a1c8cadeb84b",
  "state": "RELEASED",
  "test_wiring": {
    "input_wirings": [
      {
        "adapter_id": "direct_provisioning",
        "filters": {
          "value": "{\n    \"2022-01-01T00:00:00Z\": 1.058,\n    \"2022-01-01T00:20:48Z\": 0.699,\n    \"2022-01-01T00:41:37Z\": 1.08,\n    \"2022-01-01T01:02:26Z\": 1.054,\n    \"2022-01-01T01:23:15Z\": 0.763,\n    \"2022-01-01T01:44:04Z\": 1.034,\n    \"2022-01-01T02:04:53Z\": 0.965,\n    \"2022-01-01T02:25:42Z\": 0.601,\n    \"2022-01-01T02:46:31Z\": 0.933,\n    \"2022-01-01T03:07:20Z\": 1.081,\n    \"2022-01-01T03:28:09Z\": 2.1,\n    \"2022-01-01T03:48:58Z\": 0.988,\n    \"2022-01-01T04:09:47Z\": 0.741,\n    \"2022-01-01T04:30:36Z\": 0.647,\n    \"2022-01-01T04:51:25Z\": 0.556,\n    \"2022-01-01T05:12:14Z\": 0.453,\n    \"2022-01-01T05:33:03Z\": 1.009,\n    \"2022-01-01T05:53:52Z\": 1.72,\n    \"2022-01-01T06:14:41Z\": 1.002,\n    \"2022-01-01T06:56:19Z\": 0.857,\n    \"2022-01-01T07:17:08Z\": 0.864,\n    \"2022-01-01T07:37:57Z\": 0.606,\n    \"2022-01-01T07:58:46Z\": 0.899,\n    \"2022-01-01T08:40:24Z\": 0.62,\n    \"2022-01-01T10:03:40Z\": 0.721,\n    \"2022-01-01T10:24:29Z\": 1.193,\n    \"2022-01-01T10:45:18Z\": 0.833,\n    \"2022-01-01T11:06:07Z\": 2.06,\n    \"2022-01-01T11:26:56Z\": 0.68,\n    \"2022-01-01T11:47:45Z\": 1.136,\n    \"2022-01-01T12:08:34Z\": 0.62,\n    \"2022-01-01T12:29:23Z\": 0.946,\n    \"2022-01-01T12:50:12Z\": 0.746,\n    \"2022-01-01T13:11:01Z\": 0.833,\n    \"2022-01-01T13:31:50Z\": 0.857,\n    \"2022-01-01T14:13:28Z\": 0.947,\n    \"2022-01-01T14:34:17Z\": 0.841,\n    \"2022-01-01T14:55:06Z\": 0.668,\n    \"2022-01-01T15:15:55Z\": 0.675,\n    \"2022-01-01T15:36:44Z\": 0.84,\n    \"2022-01-01T15:57:33Z\": 0.821,\n    \"2022-01-01T16:18:22Z\": 0.625,\n    \"2022-01-01T16:39:11Z\": 1.155,\n    \"2022-01-01T17:00:00Z\": 0.968\n}"
        },
        "workflow_input_name": "series"
      },
      {
        "adapter_id": "direct_provisioning",
        "filters": {
          "value": "10"
        },
        "workflow_input_name": "min_num_desired_datapoints_in_window"
      },
      {
        "adapter_id": "direct_provisioning",
        "filters": {
          "value": "1.4"
        },
        "workflow_input_name": "buffer_factor"
      }
    ],
    "output_wirings": [],
    "dashboard_positionings": []
  },
  "type": "COMPONENT",
  "version_tag": "1.0.0"
}