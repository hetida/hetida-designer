{
  "category": "Statistic",
  "content": "\"\"\"Documentation for Moving Time Window Median\n\n# Moving Time Window Median\n\n## Description\nThis component calculates the median of observations in time windows of fixed size moving over the data with a fixed frequency.\n\n## Inputs\n* **timeseries** (Pandas Series): Series to perform the moving median calculation on.\n* **window_size** (String): Time span of each window. Can be either a Pandas frequency string based on [date offset aliases](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-offset-aliases) or a timedelta string.\n* **window_frequency** (String): Time span between window starts. Can be either a Pandas frequency string based on [date offset aliases](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-offset-aliases) or a timedelta string. For directly consecutive, non-overlapping windows set **window_frequency** to the same value as **window_size**.\n* **frequency_offset** (String): Offset of the window starts compared to 1970-01-01 00:00:00. Can be either a Pandas frequency string based on [date offset aliases](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-offset-aliases) or a timedelta string. In most cases no offset is necessary, so this can be set to zero, i.e. \"0\".\n* **interval_type** (String): The string must be one of \"left_closed\", \"right_open\", \"right_closed\", \"left_closed\" \"closed\", or \"open\". In case a datapoint is on the left or right edge of a window this option determines if it belongs to that window or not, but potentially a neighbouring window.\n* **label_position** (String): The string must be either \"left\", \"center\", or \"right\". This option determines which timestamp is provided to represent the window for the corresponding median in the output time series. \n\n## Outputs\n* **window_medians** (Pandas Series): Series with the calculated medians of each window.\n\n## Details\nThe datapoints of the **timeseries** are associated with time windows whose lengths are specified by **window_size**, and which are repeated with the frequency specified by **window_frequency** and the offset specified by **frequency_offset**.\nTo obtain for example windows with a **window_frequency** of \"5min\" that do not start at :00, :05, :10, :15 and so on, but instead at :04, :09, :14, :19 and so on, just set the **frequency_offset** to \"4min\" as in the example below.\n\nThe parameter **interval_type** is used to determine if a datapoint just on the edge of a window belongs to that window. The values \"left_closed\" and \"right_open\" median that a point on the left edge of a window belongs to this window, whereas a point on its right edge does not belong to it. The values \"right_closed\" and \"left_open\" median the same but vice versa, wheras \"closed\" medians that both belong to the window, and \"open\" medians that none of these points belong to the window.\n\nThe median of all datapoints associated to the same time period is calculated. The value of **label_position** determines at which position of the window the label for the median value of the window should be placed.\n\nThe time series does not need to have a regular frequency, and the window size can even be smaller than the smallest distance between successive observations, which then results in empty windows. For empty windows, the result value is NaN.\nIf NaN values are present in the original time series, they are eliminated before calculating the median.\n\nTo reduce the execution time, if possible (**window_frequency** and **window_size** are identical, the **label_position** is \"left\" or \"right\") the Pandas function resample is used instead of the Pandas function rolling.\n\n## Examples\nThe json input of a typical call of this component is\n```\n{\n    \"timeseries\": {\n        \"2022-12-06 23:17:14+00:00\": 14.360453,\n        \"2022-12-06 23:18:14+00:00\": 14.872439,\n        \"2022-12-06 23:19:14+00:00\": 15.803046,\n        \"2022-12-06 23:20:14+00:00\": 13.661063,\n        \"2022-12-06 23:21:14+00:00\": 14.969653,\n        \"2022-12-06 23:22:14+00:00\": 13.530460,\n        \"2022-12-06 23:23:14+00:00\": 14.009814,\n        \"2022-12-06 23:24:14+00:00\": 13.708907,\n        \"2022-12-06 23:25:14+00:00\": 15.119281,\n        \"2022-12-06 23:26:14+00:00\": 15.666053,\n        \"2022-12-06 23:27:14+00:00\": 15.488811,\n        \"2022-12-06 23:28:14+00:00\": 15.515572,\n        \"2022-12-06 23:29:14+00:00\": 14.767891,\n        \"2022-12-06 23:30:14+00:00\": 13.726783,\n        \"2022-12-06 23:31:14+00:00\": 14.997352,\n        \"2022-12-06 23:32:14+00:00\": 13.015161,\n        \"2022-12-06 23:33:14+00:00\": 15.079884,\n        \"2022-12-06 23:34:14+00:00\": 15.001638,\n        \"2022-12-06 23:35:14+00:00\": 16.035476,\n        \"2022-12-06 23:36:14+00:00\": 14.545874,\n        \"2022-12-06 23:37:14+00:00\": 13.970260,\n        \"2022-12-06 23:38:14+00:00\": 15.045999,\n        \"2022-12-06 23:39:14+00:00\": 13.824304,\n        \"2022-12-06 23:40:14+00:00\": 13.620449,\n        \"2022-12-06 23:41:14+00:00\": 15.146005,\n        \"2022-12-06 23:42:14+00:00\": 14.796941,\n        \"2022-12-06 23:43:14+00:00\": 17.036046,\n        \"2022-12-06 23:44:14+00:00\": 14.976151,\n        \"2022-12-06 23:45:14+00:00\": 14.637615,\n        \"2022-12-06 23:46:14+00:00\": 15.195011,\n        \"2022-12-06 23:47:14+00:00\": 14.082022,\n        \"2022-12-06 23:48:14+00:00\": 15.311653,\n        \"2022-12-06 23:49:14+00:00\": 15.534084,\n        \"2022-12-06 23:50:14+00:00\": 15.020099,\n        \"2022-12-06 23:51:14+00:00\": 14.020416,\n        \"2022-12-06 23:52:14+00:00\": 13.779699,\n        \"2022-12-06 23:53:14+00:00\": 14.407253,\n        \"2022-12-06 23:54:14+00:00\": 15.180839,\n        \"2022-12-06 23:55:14+00:00\": 14.618573,\n        \"2022-12-06 23:56:14+00:00\": 14.194774,\n        \"2022-12-06 23:57:14+00:00\": 14.653221,\n        \"2022-12-06 23:58:14+00:00\": 14.911146,\n        \"2022-12-06 23:59:14+00:00\": 14.951289,\n        \"2022-12-07 00:00:14+00:00\": 15.005731,\n        \"2022-12-07 00:01:14+00:00\": 15.708401,\n        \"2022-12-07 00:02:14+00:00\": 13.605439,\n        \"2022-12-07 00:03:14+00:00\": 14.620927,\n        \"2022-12-07 00:04:14+00:00\": 15.181250,\n        \"2022-12-07 00:05:14+00:00\": 13.912724,\n        \"2022-12-07 00:06:14+00:00\": 14.060204\n    },\n    \"window_size\": \"15min\",\n    \"window_frequency\": \"5min\",\n    \"frequency_offset\": \"4min\",\n    \"interval_type\": \"left_closed\",\n    \"label_positions\": \"left\"\n}\n```\nThe expected output is\n```\n\"median_windows\": {\n    \"2022-12-06T23:14:00.000Z\": 14.616446,\n    \"2022-12-06T23:19:00.000Z\": 14.3948072,\n    \"2022-12-06T23:24:00.000Z\": 15.0997248,\n    \"2022-12-06T23:29:00.000Z\": 14.3174142,\n    \"2022-12-06T23:34:00.000Z\": 14.9198494,\n    \"2022-12-06T23:39:00.000Z\": 14.884749,\n    \"2022-12-06T23:44:00.000Z\": 14.8404904,\n    \"2022-12-06T23:49:00.000Z\": 14.5523102,\n    \"2022-12-06T23:54:00.000Z\": 14.7117106,\n    \"2022-12-06T23:59:00.000Z\": 14.7783574,\n    \"2022-12-07T00:04:00.000Z\": 14.384726\n}\n```\n\"\"\"\n\nfrom typing import Any, Literal, Optional\n\nimport numba\nimport numpy as np\nimport pandas as pd\n\n\ndef freqstr2dateoffset(freqstr: str) -> pd.DateOffset:\n    \"\"\"Transform frequency string to Pandas DateOffset.\"\"\"\n    return pd.tseries.frequencies.to_offset(freqstr)\n\n\ndef freqstr2timedelta(freqstr: str) -> pd.Timedelta:\n    \"\"\"Transform frequency string to Pandas Timedelta.\"\"\"\n    try:\n        return pd.to_timedelta(freqstr)\n    except ValueError:\n        return pd.to_timedelta(freqstr2dateoffset(freqstr))\n\n\ndef shift_timestamp_to_the_left_onto_rhythm(\n    timestamp: pd.Timestamp,\n    window_frequency: pd.DateOffset,\n    frequency_offset: pd.Timedelta,\n) -> pd.Timestamp:\n    \"\"\"Shift a timestamp to the left in the rhythm.\n\n    The parameters window_frequency and frequency_offset define a kind of \"rhythm\".\n    For example a window_frequency of \"5min\" and a frequency_offset of \"1min\" define the\n    rhythm which contains all timestamps, where the minutes are 01, 06, 11, 16, and so on.\n    The provided timestamp is shifted to the left onto the closest timestamp of this rhythm.\n\n    Conveniently, the Pandas class Timestamp comes with a method `floor`, which is similar to\n    the mathematical method `floor`, but instead of a decimal place takes into account the\n    specified frequency.\n\n    It is not completely obvious how the frequency_offset needs to be taken into account so that the\n    shifted timestamp actually lies in the desired interval:\n        timestamp - window_frequency < shifted <= timestamp\n    so in the following a little proof is provided:\n\n    On the one hand we have:\n        frequency_offset < window_frequency\n        shifted = (timestamp - frequency_offset).floor(freq=window_frequency) + frequency_offset\n    <-> shifted - frequency_offset = (timestamp - frequency_offset).floor(freq=window_frequency)\n                                  <=  timestamp - frequency_offset\n     -> shifted <= timestamp\n\n    On the other hand:\n        shifted - frequency_offset = (timestamp - frequency_offset).floor(freq=window_frequency)\n                                   >  timestamp - frequency_offset - window_frequency\n     -> shifted > timestamp - window_frequency\n    \"\"\"\n    return (timestamp - frequency_offset).floor(\n        freq=window_frequency\n    ) + frequency_offset\n\n\ndef shift_timestamp_to_the_right_onto_rhythm(\n    timestamp: pd.Timestamp,\n    window_frequency: pd.DateOffset,\n    frequency_offset: pd.Timedelta,\n) -> pd.Timestamp:\n    \"\"\"Shift a timestamp to the right in the rhythm.\n\n    The parameters window_frequency and frequency_offset define a kind of \"rhythm\".\n    The specified timestamp is shifted to the right onto the closest timestamp of this rhythm.\n\n    Conveniently, the Pandas class Timestamp has a method `ceil` that is similar to the\n    mathematical method `ceil`, but instead of a decimal place, it takes into account the\n    specified frequency.\n\n    It is not completely obvious how the frequency_offset must be taken into account so that\n    the shifted timestamp actually lies in the desired interval:\n        timestamp <= shifted < timestamp + window_frequency\n    The proof that the implemented code fulfills this requirement is analogous to the one for\n    `shift_timestamp_to_the_left_in_rhythm`.\n    \"\"\"\n    return (timestamp - frequency_offset).ceil(freq=window_frequency) + frequency_offset\n\n\ndef right_window_edge_from_left_window_edge(\n    left_window_edge: pd.Timestamp, window_size: pd.DateOffset\n) -> pd.Timestamp:\n    return left_window_edge + window_size\n\n\ndef determine_right_window_edges(\n    first_index: pd.Timestamp,\n    last_index: pd.Timestamp,\n    window_size: pd.DateOffset,\n    window_frequency: pd.DateOffset,\n    frequency_offset: pd.Timedelta,\n) -> pd.DatetimeIndex:\n    \"\"\"Determine right window edges of all windows containing first_index and last_index.\n\n    This function determines the right edges of the windows for which the median shall be calculated.\n\n    The parameters window_frequency and frequency_offset define an endless \"rhythm\" where left\n    edges of windows should be located. From first_index and last_index the left edges of earliest\n    and latest window containing these timestamps are determined. Using the window_size left window\n    edges are transformed to right window edges. Finally the list of all right window edges is\n    determined and returned.\n\n    The right edges are determined because the Pandas rolling method only offers the possibility to\n    operate on windows that center around the current point or on windows for which the current\n    point is the right edge.\n    \"\"\"\n    earliest_possible_left_edge_of_window_containing_first_index = (\n        first_index - window_size\n    )\n    first_window_left_edge = shift_timestamp_to_the_right_onto_rhythm(\n        timestamp=earliest_possible_left_edge_of_window_containing_first_index,\n        window_frequency=window_frequency,\n        frequency_offset=frequency_offset,\n    )\n    first_window_right_boundary = right_window_edge_from_left_window_edge(\n        left_window_edge=first_window_left_edge, window_size=window_size\n    )\n\n    latest_possible_left_edge_of_window_containing_last_index = last_index\n    last_window_left_boundary = shift_timestamp_to_the_left_onto_rhythm(\n        timestamp=latest_possible_left_edge_of_window_containing_last_index,\n        window_frequency=window_frequency,\n        frequency_offset=frequency_offset,\n    )\n    last_window_right_boundary = right_window_edge_from_left_window_edge(\n        left_window_edge=last_window_left_boundary, window_size=window_size\n    )\n\n    return pd.date_range(\n        start=first_window_right_boundary,\n        end=last_window_right_boundary,\n        freq=window_frequency,\n        inclusive=\"both\",\n    )\n\n\ndef median_of_values_excluding_nan(array: np.array):\n    return np.median(array[~np.isnan(array)])\n\n\n@numba.njit\ndef median_of_values_excluding_nan_with_numba(array: np.array):\n    return np.median(array[~np.isnan(array)])\n\n\ndef calculate_moving_time_window_median(\n    timeseries: pd.Series,\n    window_size: pd.DateOffset,\n    window_frequency: pd.DateOffset,\n    frequency_offset: pd.Timedelta,\n    inclusive: Literal[\n        \"left_closed\", \"right_open\", \"right_closed\", \"left_open\", \"closed\", \"open\"\n    ],\n    label_position: Literal[\"left\", \"center\", \"right\"],\n    engine: Optional[Literal[\"numba\"]],\n) -> pd.Series:\n    \"\"\"Calculate the periodically shifting median for a constant time window.\n\n    timeseries (Pandas Series): Series to perform the periodically shifting time window median\n        calculation on.\n    window_size (Pandas DateOffset): Time span of each window.\n    window_frequency (Pandas DateOffset): Frequency of windows for which the median is calculated,\n        i.e. time delta between the start (or end) of each two consecutive windows.\n        For directly consecutive, non-overlapping windows set window_frequency to the same value as\n        window_size. If the window_frequency is smaller than the window_size the windows will\n        overlap. If the window_frequency is larger than the window_size, their will be gaps between\n        each two successive windows.\n    frequency_offset (Pandas Timedelta): Offset of the window starts compared to\n        1970-01-01 00:00:00. In most cases no offset is necessary, so this can be set to zero,\n        i.e. \"0\".\n    inclusive (string): The string must be either \"left\" or \"right\".\n        In case a datapoint is on the left or right border of a window this option\n        determines if it belongs to that window or not, but potentially a neighbouring window.\n    label_position (string): The string must be either \"left\", \"center\", or \"right\".\n        This option determines which timestamp is provided to represent the window for the\n        corresponding median in the output time series.\n\n    To reduce the runtime, if possible (window_frequency and window_size are identical, the\n    label_position is \"left\" or \"right\") the Pandas function resample is used instead of the Pandas\n    function rolling.\n    \"\"\"\n    if not isinstance(timeseries.index, pd.DatetimeIndex):\n        raise TypeError(\n            \"This component is exclusively for Pandas Series with a Pandas DatetimeIndex!\"\n        )\n\n    timeseries.sort_index(inplace=True)\n\n    frequency_offset = frequency_offset % window_frequency\n\n    if window_size == window_frequency and inclusive in [\"left\", \"right\"]:\n        # resample is the fastest method, if it can be used\n        result = timeseries.resample(\n            rule=window_size,\n            closed=inclusive,\n            label=\"right\",\n            origin=\"epoch\",  # default: \"start_day\"\n            # both have the same result for frequencies\n            # which are multiples of a day or divde a day evenly\n            # for other frequencies \"start_day\" will result in\n            # varying output depending on the start of the series\n            offset=frequency_offset,\n        ).median()\n    else:\n        # default label position in rolling is right\n        # left is  not possible, only alternative is center\n        right_window_boundaries = determine_right_window_edges(\n            first_index=timeseries.index[0],\n            last_index=timeseries.index[-1],\n            window_size=window_size,\n            window_frequency=window_frequency,\n            frequency_offset=frequency_offset,\n        )\n\n        reindexed_timeseries = timeseries.reindex(\n            index=right_window_boundaries.union(timeseries.index)\n        )\n\n        result = reindexed_timeseries.rolling(\n            window_size.freqstr, closed=inclusive\n        ).apply(\n            median_of_values_excluding_nan_with_numba\n            if engine == \"numba\"\n            else median_of_values_excluding_nan,\n            raw=True,\n            engine=engine,\n        )\n\n        result = result.reindex(index=right_window_boundaries)\n\n    if label_position == \"center\":\n        result = result.shift(freq=-pd.to_timedelta(window_size) / 2)\n    elif label_position == \"left\":\n        result = result.shift(freq=-pd.to_timedelta(window_size))\n\n    return result\n\n\n# ***** DO NOT EDIT LINES BELOW *****\n# These lines may be overwritten if component details or inputs/outputs change.\nCOMPONENT_INFO = {\n    \"inputs\": {\n        \"timeseries\": {\"data_type\": \"SERIES\"},\n        \"window_size\": {\"data_type\": \"STRING\"},\n        \"window_frequency\": {\"data_type\": \"STRING\"},\n        \"frequency_offset\": {\"data_type\": \"STRING\"},\n        \"interval_type\": {\"data_type\": \"STRING\"},\n        \"label_position\": {\"data_type\": \"STRING\"},\n    },\n    \"outputs\": {\n        \"window_medians\": {\"data_type\": \"SERIES\"},\n    },\n    \"name\": \"Moving Time Window Median\",\n    \"category\": \"Statistic\",\n    \"description\": \"Calculate moving time window median values\",\n    \"version_tag\": \"1.0.0\",\n    \"id\": \"dc30af71-2872-4fe0-8a09-20d9300871ba\",\n    \"revision_group_id\": \"47267bb5-d291-432f-abaa-fd6da7cdbd48\",\n    \"state\": \"RELEASED\",\n    \"released_timestamp\": \"2023-03-15T16:32:13.268394+00:00\",\n}\n\nfrom hdutils import parse_default_value  # noqa: E402, F401\n\n\ndef main(\n    *,\n    timeseries,\n    window_size,\n    window_frequency,\n    frequency_offset,\n    interval_type,\n    label_position,\n):\n    # entrypoint function for this component\n    # ***** DO NOT EDIT LINES ABOVE *****\n    # write your code here.\n\n    inclusive_string_from_interval_type = {\n        \"closed\": \"both\",\n        \"open\": \"neither\",\n        \"left_closed\": \"left\",\n        \"right_open\": \"left\",\n        \"right_closed\": \"right\",\n        \"left_open\": \"right\",\n    }\n\n    if interval_type not in inclusive_string_from_interval_type:\n        msg = (\n            f\"'{interval_type}' is not allowed as input for interval_type!\\n\"\n            \"Please use one of the following options instead:\\n\"\n            + \"\\n\".join(option for option in inclusive_string_from_interval_type.keys())\n            + \"\\n\"\n        )\n        raise ValueError(msg)\n\n    return {\n        \"window_medians\": calculate_moving_time_window_median(\n            timeseries=timeseries,\n            window_size=freqstr2dateoffset(window_size),\n            window_frequency=freqstr2dateoffset(window_frequency),\n            frequency_offset=freqstr2timedelta(frequency_offset),\n            inclusive=inclusive_string_from_interval_type[interval_type],\n            label_position=label_position,\n            engine=\"numba\",\n        )\n    }\n\n\nTEST_WIRING_FROM_PY_FILE_IMPORT = {\n    \"input_wirings\": [\n        {\n            \"workflow_input_name\": \"timeseries\",\n            \"adapter_id\": \"direct_provisioning\",\n            \"filters\": {\n                \"value\": '{\\n    \"2022-12-06 23:17:14+00:00\": 14.360453,\\n    \"2022-12-06 23:18:14+00:00\": 14.872439,\\n    \"2022-12-06 23:19:14+00:00\": 15.803046,\\n    \"2022-12-06 23:20:14+00:00\": 13.661063,\\n    \"2022-12-06 23:21:14+00:00\": 14.969653,\\n    \"2022-12-06 23:22:14+00:00\": 13.530460,\\n    \"2022-12-06 23:23:14+00:00\": 14.009814,\\n    \"2022-12-06 23:24:14+00:00\": 13.708907,\\n    \"2022-12-06 23:25:14+00:00\": 15.119281,\\n    \"2022-12-06 23:26:14+00:00\": 15.666053,\\n    \"2022-12-06 23:27:14+00:00\": 15.488811,\\n    \"2022-12-06 23:28:14+00:00\": 15.515572,\\n    \"2022-12-06 23:29:14+00:00\": 14.767891,\\n    \"2022-12-06 23:30:14+00:00\": 13.726783,\\n    \"2022-12-06 23:31:14+00:00\": 14.997352,\\n    \"2022-12-06 23:32:14+00:00\": 13.015161,\\n    \"2022-12-06 23:33:14+00:00\": 15.079884,\\n    \"2022-12-06 23:34:14+00:00\": 15.001638,\\n    \"2022-12-06 23:35:14+00:00\": 16.035476,\\n    \"2022-12-06 23:36:14+00:00\": 14.545874,\\n    \"2022-12-06 23:37:14+00:00\": 13.970260,\\n    \"2022-12-06 23:38:14+00:00\": 15.045999,\\n    \"2022-12-06 23:39:14+00:00\": 13.824304,\\n    \"2022-12-06 23:40:14+00:00\": 13.620449,\\n    \"2022-12-06 23:41:14+00:00\": 15.146005,\\n    \"2022-12-06 23:42:14+00:00\": 14.796941,\\n    \"2022-12-06 23:43:14+00:00\": 17.036046,\\n    \"2022-12-06 23:44:14+00:00\": 14.976151,\\n    \"2022-12-06 23:45:14+00:00\": 14.637615,\\n    \"2022-12-06 23:46:14+00:00\": 15.195011,\\n    \"2022-12-06 23:47:14+00:00\": 14.082022,\\n    \"2022-12-06 23:48:14+00:00\": 15.311653,\\n    \"2022-12-06 23:49:14+00:00\": 15.534084,\\n    \"2022-12-06 23:50:14+00:00\": 15.020099,\\n    \"2022-12-06 23:51:14+00:00\": 14.020416,\\n    \"2022-12-06 23:52:14+00:00\": 13.779699,\\n    \"2022-12-06 23:53:14+00:00\": 14.407253,\\n    \"2022-12-06 23:54:14+00:00\": 15.180839,\\n    \"2022-12-06 23:55:14+00:00\": 14.618573,\\n    \"2022-12-06 23:56:14+00:00\": 14.194774,\\n    \"2022-12-06 23:57:14+00:00\": 14.653221,\\n    \"2022-12-06 23:58:14+00:00\": 14.911146,\\n    \"2022-12-06 23:59:14+00:00\": 14.951289,\\n    \"2022-12-07 00:00:14+00:00\": 15.005731,\\n    \"2022-12-07 00:01:14+00:00\": 15.708401,\\n    \"2022-12-07 00:02:14+00:00\": 13.605439,\\n    \"2022-12-07 00:03:14+00:00\": 14.620927,\\n    \"2022-12-07 00:04:14+00:00\": 15.181250,\\n    \"2022-12-07 00:05:14+00:00\": 13.912724,\\n    \"2022-12-07 00:06:14+00:00\": 14.060204\\n}'\n            },\n        },\n        {\n            \"workflow_input_name\": \"window_size\",\n            \"adapter_id\": \"direct_provisioning\",\n            \"filters\": {\"value\": \"15min\"},\n        },\n        {\n            \"workflow_input_name\": \"window_frequency\",\n            \"adapter_id\": \"direct_provisioning\",\n            \"filters\": {\"value\": \"5min\"},\n        },\n        {\n            \"workflow_input_name\": \"frequency_offset\",\n            \"adapter_id\": \"direct_provisioning\",\n            \"filters\": {\"value\": \"4min\"},\n        },\n        {\n            \"workflow_input_name\": \"interval_type\",\n            \"adapter_id\": \"direct_provisioning\",\n            \"filters\": {\"value\": \"left_closed\"},\n        },\n        {\n            \"workflow_input_name\": \"label_position\",\n            \"adapter_id\": \"direct_provisioning\",\n            \"filters\": {\"value\": \"left\"},\n        },\n    ]\n}\n",
  "description": "Calculate moving time window median values",
  "documentation": "# Moving Time Window Median\n\n## Description\nThis component calculates the median of observations in time windows of fixed size moving over the data with a fixed frequency.\n\n## Inputs\n* **timeseries** (Pandas Series): Series to perform the moving median calculation on.\n* **window_size** (String): Time span of each window. Can be either a Pandas frequency string based on [date offset aliases](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-offset-aliases) or a timedelta string.\n* **window_frequency** (String): Time span between window starts. Can be either a Pandas frequency string based on [date offset aliases](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-offset-aliases) or a timedelta string. For directly consecutive, non-overlapping windows set **window_frequency** to the same value as **window_size**.\n* **frequency_offset** (String): Offset of the window starts compared to 1970-01-01 00:00:00. Can be either a Pandas frequency string based on [date offset aliases](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-offset-aliases) or a timedelta string. In most cases no offset is necessary, so this can be set to zero, i.e. \"0\".\n* **interval_type** (String): The string must be one of \"left_closed\", \"right_open\", \"right_closed\", \"left_closed\" \"closed\", or \"open\". In case a datapoint is on the left or right edge of a window this option determines if it belongs to that window or not, but potentially a neighbouring window.\n* **label_position** (String): The string must be either \"left\", \"center\", or \"right\". This option determines which timestamp is provided to represent the window for the corresponding median in the output time series. \n\n## Outputs\n* **window_medians** (Pandas Series): Series with the calculated medians of each window.\n\n## Details\nThe datapoints of the **timeseries** are associated with time windows whose lengths are specified by **window_size**, and which are repeated with the frequency specified by **window_frequency** and the offset specified by **frequency_offset**.\nTo obtain for example windows with a **window_frequency** of \"5min\" that do not start at :00, :05, :10, :15 and so on, but instead at :04, :09, :14, :19 and so on, just set the **frequency_offset** to \"4min\" as in the example below.\n\nThe parameter **interval_type** is used to determine if a datapoint just on the edge of a window belongs to that window. The values \"left_closed\" and \"right_open\" median that a point on the left edge of a window belongs to this window, whereas a point on its right edge does not belong to it. The values \"right_closed\" and \"left_open\" median the same but vice versa, wheras \"closed\" medians that both belong to the window, and \"open\" medians that none of these points belong to the window.\n\nThe median of all datapoints associated to the same time period is calculated. The value of **label_position** determines at which position of the window the label for the median value of the window should be placed.\n\nThe time series does not need to have a regular frequency, and the window size can even be smaller than the smallest distance between successive observations, which then results in empty windows. For empty windows, the result value is NaN.\nIf NaN values are present in the original time series, they are eliminated before calculating the median.\n\nTo reduce the execution time, if possible (**window_frequency** and **window_size** are identical, the **label_position** is \"left\" or \"right\") the Pandas function resample is used instead of the Pandas function rolling.\n\n## Examples\nThe json input of a typical call of this component is\n```\n{\n    \"timeseries\": {\n        \"2022-12-06 23:17:14+00:00\": 14.360453,\n        \"2022-12-06 23:18:14+00:00\": 14.872439,\n        \"2022-12-06 23:19:14+00:00\": 15.803046,\n        \"2022-12-06 23:20:14+00:00\": 13.661063,\n        \"2022-12-06 23:21:14+00:00\": 14.969653,\n        \"2022-12-06 23:22:14+00:00\": 13.530460,\n        \"2022-12-06 23:23:14+00:00\": 14.009814,\n        \"2022-12-06 23:24:14+00:00\": 13.708907,\n        \"2022-12-06 23:25:14+00:00\": 15.119281,\n        \"2022-12-06 23:26:14+00:00\": 15.666053,\n        \"2022-12-06 23:27:14+00:00\": 15.488811,\n        \"2022-12-06 23:28:14+00:00\": 15.515572,\n        \"2022-12-06 23:29:14+00:00\": 14.767891,\n        \"2022-12-06 23:30:14+00:00\": 13.726783,\n        \"2022-12-06 23:31:14+00:00\": 14.997352,\n        \"2022-12-06 23:32:14+00:00\": 13.015161,\n        \"2022-12-06 23:33:14+00:00\": 15.079884,\n        \"2022-12-06 23:34:14+00:00\": 15.001638,\n        \"2022-12-06 23:35:14+00:00\": 16.035476,\n        \"2022-12-06 23:36:14+00:00\": 14.545874,\n        \"2022-12-06 23:37:14+00:00\": 13.970260,\n        \"2022-12-06 23:38:14+00:00\": 15.045999,\n        \"2022-12-06 23:39:14+00:00\": 13.824304,\n        \"2022-12-06 23:40:14+00:00\": 13.620449,\n        \"2022-12-06 23:41:14+00:00\": 15.146005,\n        \"2022-12-06 23:42:14+00:00\": 14.796941,\n        \"2022-12-06 23:43:14+00:00\": 17.036046,\n        \"2022-12-06 23:44:14+00:00\": 14.976151,\n        \"2022-12-06 23:45:14+00:00\": 14.637615,\n        \"2022-12-06 23:46:14+00:00\": 15.195011,\n        \"2022-12-06 23:47:14+00:00\": 14.082022,\n        \"2022-12-06 23:48:14+00:00\": 15.311653,\n        \"2022-12-06 23:49:14+00:00\": 15.534084,\n        \"2022-12-06 23:50:14+00:00\": 15.020099,\n        \"2022-12-06 23:51:14+00:00\": 14.020416,\n        \"2022-12-06 23:52:14+00:00\": 13.779699,\n        \"2022-12-06 23:53:14+00:00\": 14.407253,\n        \"2022-12-06 23:54:14+00:00\": 15.180839,\n        \"2022-12-06 23:55:14+00:00\": 14.618573,\n        \"2022-12-06 23:56:14+00:00\": 14.194774,\n        \"2022-12-06 23:57:14+00:00\": 14.653221,\n        \"2022-12-06 23:58:14+00:00\": 14.911146,\n        \"2022-12-06 23:59:14+00:00\": 14.951289,\n        \"2022-12-07 00:00:14+00:00\": 15.005731,\n        \"2022-12-07 00:01:14+00:00\": 15.708401,\n        \"2022-12-07 00:02:14+00:00\": 13.605439,\n        \"2022-12-07 00:03:14+00:00\": 14.620927,\n        \"2022-12-07 00:04:14+00:00\": 15.181250,\n        \"2022-12-07 00:05:14+00:00\": 13.912724,\n        \"2022-12-07 00:06:14+00:00\": 14.060204\n    },\n    \"window_size\": \"15min\",\n    \"window_frequency\": \"5min\",\n    \"frequency_offset\": \"4min\",\n    \"interval_type\": \"left_closed\",\n    \"label_positions\": \"left\"\n}\n```\nThe expected output is\n```\n\"median_windows\": {\n    \"2022-12-06T23:14:00.000Z\": 14.616446,\n    \"2022-12-06T23:19:00.000Z\": 14.3948072,\n    \"2022-12-06T23:24:00.000Z\": 15.0997248,\n    \"2022-12-06T23:29:00.000Z\": 14.3174142,\n    \"2022-12-06T23:34:00.000Z\": 14.9198494,\n    \"2022-12-06T23:39:00.000Z\": 14.884749,\n    \"2022-12-06T23:44:00.000Z\": 14.8404904,\n    \"2022-12-06T23:49:00.000Z\": 14.5523102,\n    \"2022-12-06T23:54:00.000Z\": 14.7117106,\n    \"2022-12-06T23:59:00.000Z\": 14.7783574,\n    \"2022-12-07T00:04:00.000Z\": 14.384726\n}\n```",
  "id": "dc30af71-2872-4fe0-8a09-20d9300871ba",
  "io_interface": {
    "inputs": [
      {
        "data_type": "SERIES",
        "id": "eb9c2714-0f33-4178-af2f-125c03634582",
        "name": "timeseries",
        "type": "REQUIRED"
      },
      {
        "data_type": "STRING",
        "id": "a2cb6645-836c-40c1-bd2d-95b2d147cfa6",
        "name": "window_size",
        "type": "REQUIRED"
      },
      {
        "data_type": "STRING",
        "id": "50ca7c5d-ae49-479f-9c83-4b8cca06b9c2",
        "name": "window_frequency",
        "type": "REQUIRED"
      },
      {
        "data_type": "STRING",
        "id": "e8f5d2e1-14b8-46e1-9e8f-5e9eaccbd5f0",
        "name": "frequency_offset",
        "type": "REQUIRED"
      },
      {
        "data_type": "STRING",
        "id": "66136ef9-e303-4d41-bab0-6f5d1cfdf5a8",
        "name": "interval_type",
        "type": "REQUIRED"
      },
      {
        "data_type": "STRING",
        "id": "92bafe98-96fe-4a07-b632-c9257e166b61",
        "name": "label_position",
        "type": "REQUIRED"
      }
    ],
    "outputs": [
      {
        "data_type": "SERIES",
        "id": "2a0ec08b-fb4b-4ed7-afb9-b145f9c29cc1",
        "name": "window_medians"
      }
    ]
  },
  "name": "Moving Time Window Median",
  "released_timestamp": "2023-03-15T16:32:13.268394+00:00",
  "revision_group_id": "47267bb5-d291-432f-abaa-fd6da7cdbd48",
  "state": "RELEASED",
  "test_wiring": {
    "dashboard_positionings": [],
    "input_wirings": [
      {
        "adapter_id": "direct_provisioning",
        "filters": {
          "value": "{\n    \"2022-12-06 23:17:14+00:00\": 14.360453,\n    \"2022-12-06 23:18:14+00:00\": 14.872439,\n    \"2022-12-06 23:19:14+00:00\": 15.803046,\n    \"2022-12-06 23:20:14+00:00\": 13.661063,\n    \"2022-12-06 23:21:14+00:00\": 14.969653,\n    \"2022-12-06 23:22:14+00:00\": 13.530460,\n    \"2022-12-06 23:23:14+00:00\": 14.009814,\n    \"2022-12-06 23:24:14+00:00\": 13.708907,\n    \"2022-12-06 23:25:14+00:00\": 15.119281,\n    \"2022-12-06 23:26:14+00:00\": 15.666053,\n    \"2022-12-06 23:27:14+00:00\": 15.488811,\n    \"2022-12-06 23:28:14+00:00\": 15.515572,\n    \"2022-12-06 23:29:14+00:00\": 14.767891,\n    \"2022-12-06 23:30:14+00:00\": 13.726783,\n    \"2022-12-06 23:31:14+00:00\": 14.997352,\n    \"2022-12-06 23:32:14+00:00\": 13.015161,\n    \"2022-12-06 23:33:14+00:00\": 15.079884,\n    \"2022-12-06 23:34:14+00:00\": 15.001638,\n    \"2022-12-06 23:35:14+00:00\": 16.035476,\n    \"2022-12-06 23:36:14+00:00\": 14.545874,\n    \"2022-12-06 23:37:14+00:00\": 13.970260,\n    \"2022-12-06 23:38:14+00:00\": 15.045999,\n    \"2022-12-06 23:39:14+00:00\": 13.824304,\n    \"2022-12-06 23:40:14+00:00\": 13.620449,\n    \"2022-12-06 23:41:14+00:00\": 15.146005,\n    \"2022-12-06 23:42:14+00:00\": 14.796941,\n    \"2022-12-06 23:43:14+00:00\": 17.036046,\n    \"2022-12-06 23:44:14+00:00\": 14.976151,\n    \"2022-12-06 23:45:14+00:00\": 14.637615,\n    \"2022-12-06 23:46:14+00:00\": 15.195011,\n    \"2022-12-06 23:47:14+00:00\": 14.082022,\n    \"2022-12-06 23:48:14+00:00\": 15.311653,\n    \"2022-12-06 23:49:14+00:00\": 15.534084,\n    \"2022-12-06 23:50:14+00:00\": 15.020099,\n    \"2022-12-06 23:51:14+00:00\": 14.020416,\n    \"2022-12-06 23:52:14+00:00\": 13.779699,\n    \"2022-12-06 23:53:14+00:00\": 14.407253,\n    \"2022-12-06 23:54:14+00:00\": 15.180839,\n    \"2022-12-06 23:55:14+00:00\": 14.618573,\n    \"2022-12-06 23:56:14+00:00\": 14.194774,\n    \"2022-12-06 23:57:14+00:00\": 14.653221,\n    \"2022-12-06 23:58:14+00:00\": 14.911146,\n    \"2022-12-06 23:59:14+00:00\": 14.951289,\n    \"2022-12-07 00:00:14+00:00\": 15.005731,\n    \"2022-12-07 00:01:14+00:00\": 15.708401,\n    \"2022-12-07 00:02:14+00:00\": 13.605439,\n    \"2022-12-07 00:03:14+00:00\": 14.620927,\n    \"2022-12-07 00:04:14+00:00\": 15.181250,\n    \"2022-12-07 00:05:14+00:00\": 13.912724,\n    \"2022-12-07 00:06:14+00:00\": 14.060204\n}"
        },
        "use_default_value": false,
        "workflow_input_name": "timeseries"
      },
      {
        "adapter_id": "direct_provisioning",
        "filters": {
          "value": "15min"
        },
        "use_default_value": false,
        "workflow_input_name": "window_size"
      },
      {
        "adapter_id": "direct_provisioning",
        "filters": {
          "value": "5min"
        },
        "use_default_value": false,
        "workflow_input_name": "window_frequency"
      },
      {
        "adapter_id": "direct_provisioning",
        "filters": {
          "value": "4min"
        },
        "use_default_value": false,
        "workflow_input_name": "frequency_offset"
      },
      {
        "adapter_id": "direct_provisioning",
        "filters": {
          "value": "left_closed"
        },
        "use_default_value": false,
        "workflow_input_name": "interval_type"
      },
      {
        "adapter_id": "direct_provisioning",
        "filters": {
          "value": "left"
        },
        "use_default_value": false,
        "workflow_input_name": "label_position"
      }
    ],
    "output_wirings": []
  },
  "type": "COMPONENT",
  "version_tag": "1.0.0"
}