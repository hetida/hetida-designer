{
  "category": "Visualization",
  "content": "from typing import Optional\n\nfrom hetdesrun.component.registration import register\nfrom hetdesrun.utils import plotly_fig_to_json_dict\n\n\nimport pandas as pd\n\nfrom plotly.graph_objects import Figure\nimport plotly.express as px\n\nimport plotly.io as pio\n\npio.templates.default = None\n\nimport plotly.express as px\n\n\ndef color_scatter_plot(\n    series1: pd.Series,\n    series2: pd.Series,\n    color_series: Optional[pd.Series] = None,\n    traces_opts: dict = {\"line_color\": \"#1199bb\"},\n    layout_opts: dict = {\n        \"xaxis_title\": \"x\",\n        \"yaxis_title\": \"y\",\n        \"autosize\": True,\n        \"height\": 400,\n    },\n    line_opts: dict = {},\n):\n    \"\"\"Colored 2D Scatter Plot\n    \n    If no color_series is provided, the index will be used.\n    \n    Assumes that both series are of same / similar index.\n    \n    Automatically handles the dtype of the color_series (or index), that\n    is datetime will be converted to total_seconds from minimum timestamp,\n    and distinguishes between numeric versus categorical values.\n    \"\"\"\n\n    df = pd.DataFrame({\"x\": series1, \"y\": series2})\n\n    if color_series is None:\n        if pd.api.types.is_datetime64_any_dtype(df.index):\n            df[\"timestamps\"] = pd.Series(df.index, index=df.index)\n            df[\"seconds_from_start\"] = (\n                df.timestamps - df.timestamps.min()\n            ).dt.total_seconds()\n            fig = px.scatter(\n                df,\n                x=\"x\",\n                y=\"y\",\n                color=\"seconds_from_start\",\n                color_continuous_scale=px.colors.sequential.Plasma,\n            )\n\n        elif pd.api.types.is_numeric_dtype(df.index):\n            df[\"index\"] = pd.Series(df.index, index=df.index)\n            fig = px.scatter(\n                df,\n                x=\"x\",\n                y=\"y\",\n                color=\"index\",\n                color_continuous_scale=px.colors.sequential.Plasma,\n            )\n        else:\n            raise ValueError(\"Index is not of a dtype that allows coloring from it\")\n    else:\n        color_col_name = \"color\" if color_series.name is None else color_series.name\n        df[color_col_name] = color_series\n\n        if pd.api.types.is_datetime64_any_dtype(color_series):\n            df[color_col_name] = (\n                df[color_col_name] - df[color_col_name].min()\n            ).dt.total_seconds()\n            fig = px.scatter(\n                df,\n                x=\"x\",\n                y=\"y\",\n                color=color_col_name,\n                color_continuous_scale=px.colors.sequential.Plasma,\n            )\n\n        elif pd.api.types.is_numeric_dtype(color_series):\n            fig = px.scatter(\n                df,\n                x=\"x\",\n                y=\"y\",\n                color=color_col_name,\n                color_continuous_scale=px.colors.sequential.Plasma,\n            )\n\n        elif pd.api.types.is_categorical_dtype(\n            color_series\n        ) or pd.api.types.is_string_dtype(color_series):\n            fig = px.scatter(df, x=\"x\", y=\"y\", color=color_col_name)\n        else:\n            raise ValueError(\"Index is not of a dtype that allows coloring from it\")\n\n    fig.update_layout(**layout_opts)  # see https://plotly.com/python/figure-labels/\n    fig.update_traces(traces_opts)  # set line color?\n\n    fig.update_layout(margin=dict(l=0, r=0, b=0, t=5, pad=0))\n\n    fig.update_yaxes(automargin=True)\n    fig.update_xaxes(automargin=True)\n    return fig\n\n\ndef color_df_scatter_plot(df, x, y, color_col=None):\n    \"\"\"Wrapper for dataframes\"\"\"\n    return color_scatter_plot(\n        df[x], df[y], color_series=df[color_col] if color_col is not None else None\n    )\n\n\n# ***** DO NOT EDIT LINES BELOW *****\n# These lines may be overwritten if component details or inputs/outputs change.\nCOMPONENT_INFO = {\n    \"inputs\": {\n        \"x\": {\"data_type\": \"SERIES\"},\n        \"y\": {\"data_type\": \"SERIES\"},\n    },\n    \"outputs\": {\n        \"scatter_plot\": {\"data_type\": \"PLOTLYJSON\"},\n    },\n    \"name\": \"2D Scatter Plot colored by Index\",\n    \"category\": \"Visualization\",\n    \"description\": \"Plotting two series into the plane using index for coloring points\",\n    \"version_tag\": \"1.0.0\",\n    \"id\": \"a408a19b-70fd-5a16-958c-193d678c2c2b\",\n    \"revision_group_id\": \"a408a19b-70fd-5a16-958c-193d678c2c2b\",\n    \"state\": \"RELEASED\",\n    \"released_timestamp\": \"2022-02-09T17:33:30.703530+00:00\",\n}\n\n\ndef main(*, x, y):\n    # entrypoint function for this component\n    # ***** DO NOT EDIT LINES ABOVE *****\n    # write your function code here.\n    return {\"scatter_plot\": plotly_fig_to_json_dict(color_scatter_plot(x, y))}\n",
  "description": "Plotting two series into the plane using index for coloring points",
  "documentation": "# 2D Scatter Plot colored by Index\n\n## Description\nPlot 2D data coloring using the index.\n\n## Inputs\n* **x** (Pandas Series): Entries must be numeric. The series with the values for the x coordinates.\n* **y** (Pandas Series): Entries must be numeric. The series with the values for the y coordinates.\n\n## Outputs\n* **scatter_plot** (Plotly Json): The generated Plotly Json. This is used by the hetida designer frontend for plotting the results.\n\n## Details\nThe component plots the incoming series into a scatter plot, such that the values of the **x** series are used as x coordinates and the values of the **y** series are used as y coordinates. The resulting index of putting both series together into a DataFrame is used to color the data points. Coloring method is inferred from the dtype of the index.\n\n## Examples\nThe json input of a typical call of this component is\n```\n{\n\t\"x\": {\n    \"2019-11-29T01:00:00.000Z\": 10.533,\n    \"2019-11-29T02:00:00.000Z\": 10.559,\n    \"2019-11-29T03:00:00.000Z\": 9.7662,\n    \"2019-11-29T04:00:00.000Z\": 11.2332,\n    \"2019-11-29T05:00:00.000Z\": 11.0683,\n    \"2019-11-29T06:00:00.000Z\": 11.2072,\n    \"2019-11-29T07:00:00.000Z\": 11.1522,\n    \"2019-11-29T08:00:00.000Z\": 11.1522,\n    \"2019-11-29T09:00:00.000Z\": 11.1522,\n    \"2019-11-29T10:00:00.000Z\": 11.4473,\n    \"2019-11-29T11:00:00.000Z\": 11.3142,\n    \"2019-11-29T12:00:00.000Z\": 11.3403,\n    \"2019-11-29T13:00:00.000Z\": 11.375,\n    \"2019-11-29T14:00:00.000Z\": 12,\n    \"2019-11-29T15:00:00.000Z\": 11.4763,\n    \"2019-11-29T16:00:00.000Z\": 12,\n    \"2019-11-29T17:00:00.000Z\": 12,\n    \"2019-11-29T18:00:00.000Z\": 12,\n    \"2019-11-29T19:00:00.000Z\": 12,\n    \"2019-11-29T20:00:00.000Z\": 12,\n    \"2019-11-29T21:00:00.000Z\": 12,\n    \"2019-11-29T22:00:00.000Z\": 12,\n    \"2019-11-29T23:00:00.000Z\": 12,\n    \"2019-11-30T01:00:00.000Z\": 10.8918,\n    \"2019-11-30T02:00:00.000Z\": 10.64,\n    \"2019-11-30T03:00:00.000Z\": 10.5648,\n    \"2019-11-30T04:00:00.000Z\": 10.912,\n    \"2019-11-30T05:00:00.000Z\": 12,\n    \"2019-11-30T06:00:00.000Z\": 10.912,\n    \"2019-11-30T07:00:00.000Z\": 12,\n    \"2019-11-30T08:00:00.000Z\": 12,\n    \"2019-11-30T09:00:00.000Z\": 11.3663,\n    \"2019-11-30T10:00:00.000Z\": 11.1262,\n    \"2019-11-30T11:00:00.000Z\": 10.7471,\n    \"2019-11-30T12:00:00.000Z\": 12,\n    \"2019-11-30T13:00:00.000Z\": 12,\n    \"2019-11-30T14:00:00.000Z\": 12,\n    \"2019-11-30T15:00:00.000Z\": 12\n\t},\n\t\"y\": {\n    \"2019-11-29T01:00:00.000Z\": 10.7533,\n    \"2019-11-29T02:00:00.000Z\": 10.759,\n    \"2019-11-29T03:00:00.000Z\": 9.9662,\n    \"2019-11-29T04:00:00.000Z\": 11.1332,\n    \"2019-11-29T05:00:00.000Z\": 11.0083,\n    \"2019-11-29T06:00:00.000Z\": 11.1072,\n    \"2019-11-29T07:00:00.000Z\": 11.1222,\n    \"2019-11-29T08:00:00.000Z\": 11.1322,\n    \"2019-11-29T09:00:00.000Z\": 11.1422,\n    \"2019-11-29T10:00:00.000Z\": 11.7473,\n    \"2019-11-29T11:00:00.000Z\": 11.4142,\n    \"2019-11-29T12:00:00.000Z\": 11.4403,\n    \"2019-11-29T13:00:00.000Z\": 11.475,\n    \"2019-11-29T14:00:00.000Z\": 12,\n    \"2019-11-29T15:00:00.000Z\": 11.4763,\n    \"2019-11-29T16:00:00.000Z\": 12,\n    \"2019-11-29T17:00:00.000Z\": 12,\n    \"2019-11-29T18:00:00.000Z\": 13,\n    \"2019-11-29T19:00:00.000Z\": 12,\n    \"2019-11-29T20:00:00.000Z\": 12,\n    \"2019-11-29T21:00:00.000Z\": 13,\n    \"2019-11-29T22:00:00.000Z\": 12,\n    \"2019-11-29T23:00:00.000Z\": 12,\n    \"2019-11-30T01:00:00.000Z\": 10.7918,\n    \"2019-11-30T02:00:00.000Z\": 10.34,\n    \"2019-11-30T03:00:00.000Z\": 10.2648,\n    \"2019-11-30T04:00:00.000Z\": 10.112,\n    \"2019-11-30T05:00:00.000Z\": 11,\n    \"2019-11-30T06:00:00.000Z\": 10.312,\n    \"2019-11-30T07:00:00.000Z\": 11,\n    \"2019-11-30T08:00:00.000Z\": 12,\n    \"2019-11-30T09:00:00.000Z\": 11.3663,\n    \"2019-11-30T10:00:00.000Z\": 11.1262,\n    \"2019-11-30T11:00:00.000Z\": 10.7471,\n    \"2019-11-30T12:00:00.000Z\": 11,\n    \"2019-11-30T13:00:00.000Z\": 11,\n    \"2019-11-30T14:00:00.000Z\": 11,\n    \"2019-11-30T15:00:00.000Z\": 11.5\n    }\n}\n```\n",
  "id": "a408a19b-70fd-5a16-958c-193d678c2c2b",
  "io_interface": {
    "inputs": [
      {
        "data_type": "SERIES",
        "id": "2e61e06b-a7dc-6ea6-efb7-dc7bf68890b8",
        "name": "x",
        "type": "REQUIRED"
      },
      {
        "data_type": "SERIES",
        "id": "050d0420-21c8-8560-7f97-40f2f93cb9d3",
        "name": "y",
        "type": "REQUIRED"
      }
    ],
    "outputs": [
      {
        "data_type": "PLOTLYJSON",
        "id": "66990a60-30fa-7a61-65f6-0c6a27636b83",
        "name": "scatter_plot"
      }
    ]
  },
  "name": "2D Scatter Plot colored by Index",
  "released_timestamp": "2022-02-09T17:33:30.703530+00:00",
  "revision_group_id": "a408a19b-70fd-5a16-958c-193d678c2c2b",
  "state": "RELEASED",
  "test_wiring": {
    "dashboard_positionings": [],
    "input_wirings": [],
    "output_wirings": []
  },
  "type": "COMPONENT",
  "version_tag": "1.0.0"
}